# SWEA 1952.수영장


[SWEA 1952 바로가기](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PpFQaAQMDFAUq)

## 문제 요약
수영장의 이용권 4종류가 있다. 각 달의 계획을 입력받아 가장 적은 비용으로 수영장을 이용하는 방법을 찾고 그 비용을 출력하라

## 주요 조건
* 50개 테스트케이스를 합쳐서 C의 경우 3초 / C++의 경우 3초 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내

## 접근
![1](https://user-images.githubusercontent.com/99806622/218507714-c96bd0e9-ef20-4ab2-8405-b7f2b9118956.jpg)
* 이용 계획은 1월 부터 12월까지이므로 수가 적음 따라서 완전 탐색으로 접근함.
* 월당 1일 이용권, 1달 이용권, 3달 이용권, 1년 이용권 총 4가지 경우가 있음.
* 어떤 이용권을 사용하냐에 따라 다음달을 스킵할 수 있음

## 전역변수
type|변수명|의미|
---|---|---|
int[]|price|4개의 이용권의 가격|
int[]|calender|1년 이용 계획|
int|min_cost|1년 수영장 비용 최솟값|
int|acc_cost|1년 수영장 비용 누적값|
int[]|next_month|이용권당 넘어가야 할 다음달|

## 함수 프로토 타입
* void init(void) 이용권 가격과 1년 계획을 입력받고 1년 수영장 비용최솟값, 1년 수영장 비용 누적값을 초기화 하는 함수
* void dfs(int level) 현재 월을 입력으로 받아 모든 경우의 수를 완전 탐색을 함

## 기억해야할 점
* 최대값을 구하는 문제에서 완전탐색을 할 경우 재귀호출 마다 그 상황에서 가질 수 있는 최대값이 이미 구해진 최댓값보다 작다면 더이상 재귀호출하지 말고 리턴하면 경우의수를 많이 줄일 수 있다.


# SWEA 1953.탈주범 검거


[SWEA 1953 바로가기](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PpLlKAQ4DFAUq)

## 문제 요약
탈주범이 지하로 도망갔다. 지하에는 맨홀 뚜껑이 있는데 모양에 따라 탈주범이 갈 수 있는 곳과 없는 곳이 있다. 탈주범은 1시간마다 한칸씩 이동이 가능하다. L시간 이후 탈주범이 있을 수 있는 모든 장소의 수를 출력하라

## 주요 조건
* 50개 테스트케이스를 합쳐서 C의 경우 3초 / C++의 경우 3초, 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내
* 지하 터널 지도의 세로 크기 N, 가로 크기 M은 각각 5 이상 50 이하이다. (5 ≤ N, M ≤ 50)
*  탈출 후 소요된 시간 L은 1 이상 20 이하이다. (1 ≤ L ≤ 20)

## 접근
![2](https://user-images.githubusercontent.com/99806622/218507751-f5b87db4-4a68-4c1a-8fb5-87c5a8f57ec4.jpg)
* 이차원 맵을 이동하는 방식이 필요하므로 flood fill 알고리즘을 이용
* 갈수 있는 방향은 상하좌우 이지만 현재위치의 터널 모양과 다음 위치의 터널 모양에 따라 이동할 수 있는지 결정됨

## 전역변수
type|변수명|의미|
---|---|---|
int[][]|map|지하 맵|
int[][]|visited|방문좌표를 체크하기 위한 이차원 배열|
int|N, M, R, C, L|map의 세로와 너비, 맨홀 위치 좌표(R,C), 탈출후 소요시간|
int|initial_MAX| 높이가 가장 높은곳의 높이|
int[][]|direct|상하좌우 방향좌표 이차원배열|
int|cnt|탈주범 이동 장수 누적값|
string[]|now_manhole_shape|현재 위치에서 방향에 따라 갈수 있는 터널 모양|
string[]|next_manhole_shape|다음 위치에서 방향에 따라 올수 있는 터널 모양|

## 함수 프로토 타입
void input(void) map의 세로와 너비, 맨홀 위치 좌표(R,C), 탈출후 소요시간, 지하 맵을 입력 받는 함수
void bfs(int R, int C) 맨홀의 위치 R,C를 입력으로 받아 flood fill 알고리즘으로 탐색하여 L시간 이후 종료되는 함수

## 기억해야할 점
* 문제를 해결하는 방법이 보여도 코드를 최대한 간결하게 짜야 실수를 줄일 수 있고 버그도 빨리 찾을 수 있다.


# SWEA 2115.벌꿀채취


[SWEA 2115 바로가기](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5V4A46AdIDFAWu)

## 문제 요약
두일꾼이 너비와 높이가 N인 일터에서 M개의 벌꿀을 가로방향 연속으로 각각 뽑는다. 뽑은 M개의 벌꿀에서 C만큼 벌꿀을 채취할 수 있는데 이 때 벌꿀통에서 채취한 벌꿀의 제곱만큼 이익을 얻는다. 두 일꾼의 이익의 최댓값을 구하시오

## 주요 조건
* 50개 테스트케이스를 합쳐서 C++의 경우 3초 / Java의 경우 3초 / Python의 경우 6초 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내
* 벌통들의 크기 N은 3 이상 10 이하의 정수이다. (3 ≤ N ≤ 10)
* 선택할 수 있는 벌통의 개수 M은 1 이상 5 이하의 정수이다. (1 ≤ M ≤ 5)
* 선택할 수 있는 벌통의 개수 M은 반드시 N 이하로만 주어진다.
* 꿀을 채취할 수 있는 최대 양 C는 10 이상 30 이하의 정수이다. (10 ≤ C ≤ 30)
* 하나의 벌통에서 채취할 수 있는 꿀의 양은 1 이상 9 이하의 정수이다.
* 하나의 벌통에서 일부분의 꿀만 채취할 수 없고, 벌통에 있는 모든 꿀을 한번에 채취해야 한다.



## 접근
![1](https://user-images.githubusercontent.com/99806622/218507714-c96bd0e9-ef20-4ab2-8405-b7f2b9118956.jpg)
* 벌꿀통의 크기가 최댓값이면 가지가 100개이고 레벨이 2인 트리가됨 ->10000
* 벌꿀통 선택은 최댓값이 벌꿀통이 5개이고 모든 선택을 할경우 5^5 = 3125가됨
* 일꾼이 2명이므로 3125 * 2 = 6250, 총 계산량 10000*6250 = 62,500,000경우임 50개 테스트 케이스 3초면 테스트 케이스 1개당 600만 연산 즉 10분1정도로 백트랙킹 해야함

## 전역변수
type|변수명|의미|
---|---|---|
int[]|price|4개의 이용권의 가격|
int[]|calender|1년 이용 계획|
int|min_cost|1년 수영장 비용 최솟값|
int|acc_cost|1년 수영장 비용 누적값|
int[]|next_month|이용권당 넘어가야 할 다음달|

## 함수 프로토 타입
* void init(void) 이용권 가격과 1년 계획을 입력받고 1년 수영장 비용최솟값, 1년 수영장 비용 누적값을 초기화 하는 함수
* void dfs(int level) 현재 월을 입력으로 받아 모든 경우의 수를 완전 탐색을 함

## 기억해야할 점
* 최대값을 구하는 문제에서 완전탐색을 할 경우 재귀호출 마다 그 상황에서 가질 수 있는 최대값이 이미 구해진 최댓값보다 작다면 더이상 재귀호출하지 말고 리턴하면 경우의수를 많이 줄일 수 있다.
