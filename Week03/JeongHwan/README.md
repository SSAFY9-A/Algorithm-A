# SWEA 2117. 홈 방범 서비스


[SWEA 2117 바로가기](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5V61LqAf8DFAWu&)

## 문제 요약
N * N 도시, 영역 크기 K, 운영비용 K * K+(k-1)*(k-1),
하나의 집이 이용할 수 있는 비용 M, 손해를 안보고 가장 많은 집에 서비스를 제공하는 영역을 찾고 서비스를 제공받는 집들의 수를 
구하라

## 주요 조건
* 50개 테스트케이스를 합쳐서 C의 경우 3초 / C++의 경우 3초 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내

## 접근
* 홈 방범 서비스의 영역이 flood-fill 알고리즘으로 체우는 방법과 같음
* 모든 영역에서 flood-fill 알고리즘으로 영역 크기를 늘려가며 집의 수와 비용을 계산하여 집의 수의 최댓값을 구함
* 얻을 수있는 최대 이익이 현재 영역의 비용보다 적다면 더이상 영역을 늘릴 필요가 없음(back-tracking)
* cost K당 비용을 미리 계산을 해놓아 계산을 줄임 (DAT)

## 전역변수
type|변수명|의미|
---|---|---|
int|N,M|맵의 너비, 집 1개당 지불 비용|
int[][]|map|맵|
int[]|cost|index의 영역으로 홈 방범 서비스를 하면 지불되는 비용|

## 함수 프로토 타입
* void init(void) 맵에 존재하는 집의수와 보안회사가 보안회사가 손해를 보지 않고 서비스를 제공할 수 있는 집들의 최댓값을 초기화
* void ff(int y, int x) (y,x)를 시작점으로 flood-fill 알고리즘으로 탐색하면서 max_house를 갱신함


# SWEA 2117. 미생물 격리

[SWEA 2382 바로가기](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV597vbqAH0DFAVl&)

## 문제 요약
N * N개의 공간, K개의 미생물 군집이 존재함, 공간의 테두리에는 약품이 있음, 미생물 군집은 한 방향으로 1시간 1칸을 이동함, 약품에 도착 후 절반 죽은 후 반대 방향으로 바뀜, 이동 후 한셀에 있는 미생물 군집들은 합쳐짐, 이 때 이동방향은 미생물 수가 많은 군집의 이동 방향이 됨, M시간 후 남아있는 미생물 수의 총 합을 구하시오.

## 주요 조건
* 50개 테스트케이스를 합쳐서 C의 경우 5초 / C++의 경우 5초 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내

## 접근
* 시뮬레이션 문제임 따라서 시뮬레이션 과정 1.이동 2.테두리 체크 3.군집 합치기 순서로 접근
* 테두리에 동시에 2군집이 가능 경우는 없음 따라서 과정 2와 3 사이의 순서를 보장함
* 군집을 합 칠때 수가 많은 군집의 방향으로 결정됨 따라서 미생물 군집을 우선순위 큐 max heap에 저장하여 큰 군집부터 이동시킴

## 구조체
* micro : 미생물 개수, (y,x)좌표, dir방향, 우선순위 큐 비교 연산 operator <
* MAP : num(현재 존재하는 총 미생물 수), dir 방향

## 전역변수
type|변수명|의미|
---|---|---|
int|N,M,K|맵의 너비, 격리시간, 군집개수|
MAP[][]|map|맵을 저장하는 이차원 배열로 좌표에 존재하는 미생물 개수와 방향이 저장됨|

## 함수 프로토 타입
* int sv(void) 우선순위 큐에 미생물 군집의 미생물 수와 좌표, 바향을 저장하고 시뮬레이션 과정인 1.이동, 2.테두리 체크, 3.군집 합치기 순서로 진행후 남아있는 미생물 수를 리턴함.
